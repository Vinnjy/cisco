## Практическое задание 1: ICMP симуляция

### Описание
Построить сеть из 3 ноутбуков, 1 пк, 1 сервера и 2 хабов. Задать для 3 ноутбуков IP-адреса в диапазоне: 192.168.1.1-192.168.1.3, для пк: 192.168.1.4, для сервера: 192.168.1.5. Посмотреть, что происходит при передаче в режиме симуляции.

### Оглавление
[Модель OSI, TCP/IP](#title0)

[ICMP симуляция](#title1)

## <a id="title0">Модель OSI, TCP/IP</a>

Прежде, чем перейти к симуляции, рассмотрим модель OSI, TCP/IP.

* **OSI** - эталанноая модель, которая подробно демонстрирует, что происходит с данными при передаче. На практике не используется.
* **TCP/IP** - модель, которая используется на практике.

Как выглядят:

<img width="1024" height="767" alt="image" src="https://github.com/user-attachments/assets/4704e277-93ea-4dbf-a559-3dbee3398325" />

* Перед передачей данные проходят каждый уровень, начиная с прикладного, заканчивая физическим. По физическому каналу доходят до другого устройтсва, там проходят все уровни от физического до прикладного (если рассматривать модель OSI и конечные устройства).
* Эти процессы называются **инкапсуляцией** и **декапсуляцией**.

> Стоит отметить, что каждый уровень ничего не знает о работе другого уровня, всего лишь передаёт данные другому.

* На каждом уровне при инкапсуляции к данным добавляются служебная информация (заголовки), при декапсуляции их считывают и преобразуют до исходного состояния (на примере разберём подробнее).

> Физический уровень и канальный уровень (MAC) реализованы на уровне железа, остальные на уровне программ.

> Принято считать, что физический, канальный, сетевой - **уровни среды**; остальные - **уровни хоста**.

> Уровни прикладной, представления, сеансовый работают с данными. Транспортный с сегментами, сетевой с пакетами, канальный с кадрами, физический с сигналами (биты). 

Теперь перейдём к примеру, чтобы понять, как работает модель.

> 1. Допустим, открыли браузер, ввели адрес и нажали enter.
> 2. Браузер (клиент) должен отправить запрос на сервер, чтобы получить данные. На этом этапе данными является адрес сайта.
> Протокол HTTP, DMS, DHCP,...

> 3. Данные спускаются на уровень представления. Здесь строка браузера преобразуется в удобный формат (понятный получателя).
> Здесь может происходить **кодирование/декодирование**, **шифрование/дешифрование**, а также сжатие.

> 4. Данные (уже не текст, который вводили) поступают на сеансовый уровень. В данном примере нет необходимости задействовать протоколы этого уровня. 
> Обычно на этом уровне указывается, какой тип соединения будет применён. Их бывает 3: **симплексное** (в одном напралении передача), **полудуплексное** (в обоих направлениях, но неодновременно), **дуплексное** (одновременно в обоих направлениях). Протокол SIP.

> 5. Данные переданы на траснпортный уровень, передача данных с помощью протокола TCP. При передаче данные разбиваются на **сегменты**, к каждому сегменту добавляются **заголовки** со служебной информацией. Указываются **логические порты получателя и отправителя**.
> На этом уровне работают такие протколы, как TCP и UDP.

> TCP обеспечивает надёжную передачу. Использует тройное рукопожатие: устройство А отправляет сегмент с флагом SYN (что хочет начать передачу), устройство В отпраляет сегмент SYN+ACK (готов принимать передачу), устройство А отправляет сегмен с флагом ACK (мы оба согласны, начинаю передачу).

> Для иллюстрации:

<img width="388" height="305" alt="image" src="https://github.com/user-attachments/assets/d4f9660e-7434-46d1-b2e2-dee2f782feea" />

> UDP использует датаграммы. Обеспечивает быструю передачу, но не гарантирует надёжность, порядок сегментов, целостность данных при передаче.

> Для иллюстрации:

<img width="378" height="114" alt="image" src="https://github.com/user-attachments/assets/005f55f2-7f3e-4b82-98fe-546635600256" />

> В практической работе с DHCP, DNS, WEB серверами можете запустить симуляции и посмотреть структуру сегментов/датаграмм. Для TCP используйте браузер в качестве HTTP запроса, для UDP используйте DNS: команда nslookup с полным доменным именем сайта (об этом в следующей практической работе).

> 6. Сегменты переданы на сетевой уровень. Сегменты разделяются на пакеты. **Сегмент = заголовок + данные**. **Пакет = сегмент + заголовок**. Заголовок сетевого уровня состоит из многих служебных параметров, но главное, что надо знать, что содержит **IP-адрес отправителя и получателя**.

> Для иллюстрации:

<img width="434" height="198" alt="image" src="https://github.com/user-attachments/assets/33da9fef-0c1e-4292-962e-56571bc52a20" />

> 7. Пакеты передаются на канальный уровень. Там они разбиваются на кадры, к ним добавляются заголовки. **Кадр = пакет + заголовок**. Заголовок содержит **MAC-адреса отправителя и получателя**, также **трейлер** для проверки целостности данных.

> Для иллюстрации:

<img width="446" height="135" alt="image" src="https://github.com/user-attachments/assets/6df47028-157d-49ac-9361-4614dcdf65ac" />

> 8. Данные поступают на физический уровень, где передаются в виде 0 и 1.

> 9. Когда сигналы (биты) доходят до получателя, сетевая карта преобразует их в кадры и отправляет на уровень выше.

> 10. На канальном уровне проверяется MAC-адрес получателя (совпадает ли полученное значение с MAC-адресом сетевой карты).
> Если нет, то кадр отбрасывается. Если да, то высчитвается полученная сумма данных и сравнивается со значением в трейлере. Если нет, то кадр отбрасывается. Если да, то преобрзование в пакет и отправка на уровень выше.

> 11. На сетевом уровне идёт проверка IP-адреса получателя. Если совпало, то преобразование в сегмент и отправка на уровень выше.
> 12. На транспортном уровне проверка служебной иформации из заголовков (что сегмент передался, какой протокол ипсользовался (если TCP, то отправят SYN+ACK или FIN+ACK), для какого порта).
> 13. На остальнх уровнях запрос обработается и вышлет HTTP-ответ.
>
> Далее тоже саоме только уже для ответа. Если объём данных будет очень большим, то он его поделят, эти куски спустят на транспортный уровень.

## <a id="title1">ICMP симуляция</a>

1. Построить схему сети

<img width="683" height="376" alt="image" src="https://github.com/user-attachments/assets/cf60245b-9f3a-48f8-b4ed-8f13c2459bae" />

> Чтобы прописать IP-адреса и префиксы, нажмите на ***Place Note*** (справа есть панель, выберите второй, считая сверху)

2. Пропишем IP-configuration и названия конечных устройств.

<img width="299" height="242" alt="image" src="https://github.com/user-attachments/assets/b39ad07e-428b-46c8-8f18-bb1a86de4710" />
</br>
<img width="305" height="244" alt="image" src="https://github.com/user-attachments/assets/2502c4d9-0d4f-420e-8103-fa9014e2ed1e" />
</br>
<img width="307" height="243" alt="image" src="https://github.com/user-attachments/assets/80cf1f5a-9a3a-427c-b758-a9eabd3784d9" />
</br>
<img width="305" height="253" alt="image" src="https://github.com/user-attachments/assets/a643d405-e6ee-4823-a267-67541865561e" />
</br>
<img width="275" height="289" alt="image" src="https://github.com/user-attachments/assets/c038fde5-000a-41e3-9646-fd7a39d1226c" />

3. Пропингуем comp1 и сервер в симуляции и посмотрим, что происходит.

> Где написано Realtime, за ним находится режим Simulation (нажмите на него)

> Нажмите на Edit Filters, уберите во всех вкладках галочки, кроме ICMP, ARP.

Но прежде, чем приступать разберёмся ICMP по подробнее.

**ICMP** - протокол для проверки сети и доступности устройств. Состоит из:
+ ICMP Echo Request (эхо запрос)
+ ICMP Echo Reply (эхо ответ)
* ICMP инкапсулируется в IP-пакеты, так как пакеты передаются по сети.

Структура ICMP:

1. Заголовок:
   * Тип сообщения (Type): 0 для ответа, 8 для запроса.
   * Код (Code): более подробная информация о типе сообщения (у типа 0 и 8 только код 0, который означает эхо-запрос и эхо-ответ).
   * Контрольная сумма (Checksum): контрольная сумма для проверки целостности сообщения.
   * Идентификатор (ID). Если делается пинг, то посылается, как правило 4 эхо-запроса, id каждого не меняется.
   * Порядковый номер (Sequence Number). Если делается пинг, то посылается, как правило 4 эхо-запроса, порядковый номер каждого меняется.
2. Поле данных.
> Данные отправителя. Оно может быть пустым или включать случайные данные, что помогает проверить, вернулись ли эти же данные обратно.

Пример:

<img width="365" height="90" alt="image" src="https://github.com/user-attachments/assets/e83d3e84-00f5-41cc-9ff5-474406c407bd" />

> С более подробной информацией о ICMP, структуре и форматах сможете ознакомится здесь: https://net.academy.lv/lection/net_LS-10RU_icmp.pdf. Для практической работы достаточно.

Теперь разберём IP подробнее. Речь пойдёт не только про адрес.

IP - протокол, который обеспечивает передачу данных в интернете и других сетях. Он отвечает на такие вопросы:
+ Как данные должны быть упакованы? (пакеты)
+ Как данные должны быть адресованы? (логические адреса)
+ Как данные должжны быть маршрутизированы в сети? (маршруты)

Cтруктура IP-пакета:

1. Заголовок:
   * версия (version): указывает, какая версия IP используется (IPv4 или IPv6).
   * длина заголовка (Internet Header Length/IHL): определяет длину заголовка в 32-битных словах. К примеру, длина заголовка — 20 байт (5 слов). Может быть больше, если используются опции.
   * тип обслуживания (Type of Service/DiffServ/DSCP): управляет приоритетом доставки пакетов (маркировка трафика). 
   * общая длина (Total Length/TL): длина пакета = заголовок + данные.
   * идентификатор (Identification/ID): для сборки фрагментированных пакетов.
   * флаги (Flags): может ли пакет быть фрагментирован и есть ли ещё фрагменты.
   * смещение фрагмента (Fragment Offset): позиция фрагмента в исходном пакете.
   * время жизни (Time To Live/TTL): количество маршрутизаторов, через которые пакет может пройти, прежде чем быть отброшенным.
   * протокол (Protocol/PRO): какой протокол верхнего уровня (например, TCP, UDP) находится в полезной нагрузке (информация для пользователя, не служебная нагрузка).
   * заголовочная сумма (Header Checksum): для заголовка, используемая для обнаружения ошибок.
   * IP-адрес отправителя (Source IP Address/SRC).
   * IP-адрес получателя (Destination IP Address/DEST).
   * Опции (Options): дополнительные поля для отладки, тестирования или специфических настроек маршрутизации.
   * Отступы (Padding): добавляются для того, чтобы длина поля "Опции" была кратна 32 битам.
2. Данные (Data): полезная нагрузка.

Пример:

<img width="443" height="182" alt="image" src="https://github.com/user-attachments/assets/b0188b2e-8800-4c9c-8d29-9e7a3227e214" />

