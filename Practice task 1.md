## Практическое задание 1: ICMP симуляция

### Описание
Построить сеть из 3 ноутбуков, 1 пк, 1 сервера и 2 хабов. Задать для 3 ноутбуков IP-адреса в диапазоне: 192.168.1.1-192.168.1.3, для пк: 192.168.1.4, для сервера: 192.168.1.5. Посмотреть, что происходит при передаче в режиме симуляции.

### Оглавление
[Модель OSI, TCP/IP](#title0)

[ICMP симуляция](#title1)

## <a id="title0">Модель OSI, TCP/IP</a>

Прежде, чем перейти к симуляции, рассмотрим модель OSI, TCP/IP.

* **OSI** - эталанноая модель, которая подробно демонстрирует, что происходит с данными при передаче. На практике не используется.
* **TCP/IP** - модель, которая используется на практике. Объединяет в себе функционал некоторых уровней модели OSI в один. Так с прикладным уровнем и канальным. Прикладной объединяет все уровни модели OSI, которые работают с данными. Канальный объединяет физический и канальный уровень модели OSI.

Для понимания:

<img width="1024" height="767" alt="image" src="https://github.com/user-attachments/assets/4704e277-93ea-4dbf-a559-3dbee3398325" />

* Перед передачей данные проходят каждый уровень, начиная с прикладного, заканчивая физическим. По физическому каналу доходят до другого устройтсва, там проходят все уровни от физического до прикладного (если рассматривать модель OSI и конечные устройства).
* Эти процессы называются **инкапсуляцией** и **декапсуляцией**.

> Стоит отметить, что каждый уровень ничего не знает о работе другого уровня, всего лишь передаёт данные другому.

* На каждом уровне при инкапсуляции к данным добавляются служебная информация (заголовки), при декапсуляции их считывают и преобразуют до исходного состояния (на примере разберём подробнее).

> Физический уровень и канальный уровень (MAC) реализованы на уровне железа, остальные на уровне программ.

> Принято считать, что физический, канальный, сетевой - **уровни среды**; остальные - **уровни хоста**.

> Уровни прикладной, представления, сеансовый работают с данными. Транспортный с сегментами, сетевой с пакетами, канальный с кадрами, физический с сигналами (биты). 

Теперь перейдём к примеру, чтобы понять, как работает модель.

> 1. Допустим, открыли браузер, ввели адрес и нажали enter.
> 2. Браузер (клиент) должен отправить запрос на сервер, чтобы получить данные. На этом этапе данными является адрес сайта.

> Протокол HTTP, DMS, DHCP,...

> 3. Данные спускаются на уровень представления. Здесь строка браузера преобразуется в удобный формат (понятный получателя).

> Здесь может происходить **кодирование/декодирование**, **шифрование/дешифрование**, а также сжатие.

> 4. Данные (уже не текст, который вводили) поступают на сеансовый уровень. В данном примере нет необходимости задействовать протоколы этого уровня.

> Обычно на этом уровне указывается, какой тип соединения будет применён. Их бывает 3: **симплексное** (в одном напралении передача), **полудуплексное** (в обоих направлениях, но неодновременно), **дуплексное** (одновременно в обоих направлениях). Протокол SIP.

> 5. Данные переданы на траснпортный уровень, передача данных с помощью протокола TCP. При передаче данные разбиваются на **сегменты**, к каждому сегменту добавляются **заголовки** со служебной информацией. Указываются **логические порты получателя и отправителя**.

> На этом уровне работают такие протколы, как TCP и UDP.

> TCP обеспечивает надёжную передачу. Использует правило тройного рукопожатия: устройство А отправляет сегмент с флагом SYN (что хочет начать передачу), устройство В отпраляет сегмент SYN+ACK (готов принимать передачу), устройство А отправляет сегмен с флагом ACK (мы оба согласны, начинаю передачу).

> Стоит отметить, что если зайдёте в cisco packet tracer и используете симуляцию для демонстрации работы HTTP протокола. Вы заметите, что после HTTP-ответа используется TCP протокол для завершения соединения (флаг FIN), работает по правилу тройного рукопожатия. 

> Для иллюстрации:

<img width="388" height="305" alt="image" src="https://github.com/user-attachments/assets/d4f9660e-7434-46d1-b2e2-dee2f782feea" />

> UDP использует датаграммы. Обеспечивает быструю передачу, но не гарантирует надёжность, порядок сегментов, целостность данных при передаче.

> Для иллюстрации:

<img width="378" height="114" alt="image" src="https://github.com/user-attachments/assets/005f55f2-7f3e-4b82-98fe-546635600256" />

> В практической работе с DHCP, DNS, WEB серверами можете запустить симуляции и посмотреть структуру сегментов/датаграмм. Для TCP используйте браузер в качестве HTTP запроса, для UDP используйте DNS: команда nslookup с полным доменным именем сайта (об этом в следующей практической работе).

> 6. Сегменты переданы на сетевой уровень. Сегменты разделяются на пакеты. **Сегмент = заголовок + данные**. **Пакет = сегмент + заголовок**. Заголовок сетевого уровня состоит из многих служебных параметров, но главное, что надо знать, что содержит **IP-адрес отправителя и получателя**.

> Для иллюстрации:

<img width="434" height="198" alt="image" src="https://github.com/user-attachments/assets/33da9fef-0c1e-4292-962e-56571bc52a20" />

> 7. Пакеты передаются на канальный уровень. Там они разбиваются на кадры, к ним добавляются заголовки. **Кадр = пакет + заголовок**. Заголовок содержит **MAC-адреса отправителя и получателя**, также **трейлер** для проверки целостности данных.

> Для иллюстрации:

<img width="446" height="135" alt="image" src="https://github.com/user-attachments/assets/6df47028-157d-49ac-9361-4614dcdf65ac" />

> 8. Данные поступают на физический уровень, где передаются в виде 0 и 1.

> 9. Когда сигналы (биты) доходят до получателя, сетевая карта преобразует их в кадры и отправляет на уровень выше.

> 10. На канальном уровне проверяется MAC-адрес получателя (совпадает ли полученное значение с MAC-адресом сетевой карты).
> Если нет, то кадр отбрасывается. Если да, то высчитвается полученная сумма данных и сравнивается со значением в трейлере. Если нет, то кадр отбрасывается. Если да, то преобрзование в пакет и отправка на уровень выше.

> 11. На сетевом уровне идёт проверка IP-адреса получателя. Если совпало, то преобразование в сегмент и отправка на уровень выше.

> 12. На транспортном уровне проверка служебной иформации из заголовков (что сегмент передался, какой протокол ипсользовался (если TCP, то отправят SYN+ACK или FIN+ACK), для какого порта).

> 13. На остальных уровнях запрос обработается и вышлет HTTP-ответ.

> Далее тоже самое только уже для ответа. Если объём данных будет очень большим, то их поделят, эти куски спустят на транспортный уровень.

> Cтоит отметить, что хабы понимают только физический уровень, коммутаторы - физический и канальный, маршрутизаторы - физический и канальный и сетевой. Если через них проходят данные, то данные, как было с конечными устройствами декапсулируются и инкапсулируются для прохождения дальше по сети.

## <a id="title1">ICMP симуляция</a>

1. Построить схему сети

<img width="683" height="376" alt="image" src="https://github.com/user-attachments/assets/cf60245b-9f3a-48f8-b4ed-8f13c2459bae" />

> Чтобы прописать IP-адреса и префиксы, нажмите на ***Place Note*** (справа есть панель, выберите второй, считая сверху)

2. Пропишем IP-configuration и названия конечных устройств.

<img width="299" height="242" alt="image" src="https://github.com/user-attachments/assets/b39ad07e-428b-46c8-8f18-bb1a86de4710" />
</br>
<img width="305" height="244" alt="image" src="https://github.com/user-attachments/assets/2502c4d9-0d4f-420e-8103-fa9014e2ed1e" />
</br>
<img width="307" height="243" alt="image" src="https://github.com/user-attachments/assets/80cf1f5a-9a3a-427c-b758-a9eabd3784d9" />
</br>
<img width="305" height="253" alt="image" src="https://github.com/user-attachments/assets/a643d405-e6ee-4823-a267-67541865561e" />
</br>
<img width="275" height="289" alt="image" src="https://github.com/user-attachments/assets/c038fde5-000a-41e3-9646-fd7a39d1226c" />

Но прежде, чем приступать разберёмся ICMP по подробнее.

**ICMP** - протокол для проверки сети и доступности устройств. Состоит из:
+ ICMP Echo Request (эхо запрос)
+ ICMP Echo Reply (эхо ответ)
* ICMP инкапсулируется в IP-пакеты, так как пакеты передаются по сети.

Структура ICMP:

> 1. Заголовок:
   > * Тип сообщения (Type): 0 для ответа, 8 для запроса.
   > * Код (Code): более подробная информация о типе сообщения (у типа 0 и 8 только код 0, который означает эхо-запрос и эхо-ответ).
   > * Контрольная сумма (Checksum): контрольная сумма для проверки целостности сообщения.
   > * Идентификатор (ID). Если делается пинг, то посылается, как правило 4 эхо-запроса, id каждого не меняется.
   > * Порядковый номер (Sequence Number). Если делается пинг, то посылается, как правило 4 эхо-запроса, порядковый номер каждого меняется.
> 2. Поле данных.
> Данные отправителя. Оно может быть пустым или включать случайные данные, что помогает проверить, вернулись ли эти же данные обратно.

Пример:

<img width="365" height="90" alt="image" src="https://github.com/user-attachments/assets/e83d3e84-00f5-41cc-9ff5-474406c407bd" />

> С более подробной информацией о ICMP, структуре и форматах сможете ознакомится здесь: https://net.academy.lv/lection/net_LS-10RU_icmp.pdf. Для практической работы достаточно.

3. Пропингуем comp1 и сервер в симуляции и посмотрим, что происходит.

> Где написано Realtime, за ним находится режим Simulation (нажмите на него)

> Нажмите на Edit Filters, уберите во всех вкладках галочки, кроме ICMP, ARP.

<img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/f989caa6-9c1f-4303-b0e6-022f9c4757cb" />

> Формируется ICMP эхо-запрос, но перед ним отправят ARP-запрос, чтобы узнать MAC-адрес получателя.

> На следующих скриншотах показан путь ARP.

<img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/5d7922bd-8a9e-464c-9e78-9a743f90c666" />

<img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/1ee4b2ee-7a7f-4fa4-a1c1-607893072a90" />

<img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/c9a1a2a7-c3ec-46c8-adbe-36593e270109" />

<img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/dbc52482-dc55-4340-8cb5-4f4630665d57" />

<img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/7b3240cf-5f8e-46f8-8128-60c975da8114" />

<img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/1b85bfa8-6757-4de2-a7eb-b106d73a044e" />

> На следующих скриншотах показан путь ICMP эхо-запроса и ответа.

<img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/0e19432c-1fc1-4d22-8fb9-4102566201cd" />

<img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/bd1e4ecd-b41b-468c-965f-3f71ce8aff87" />

<img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/21792b5f-9c94-458a-9cba-b09532617aab" />

<img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/62534d26-0172-4d6b-b08f-7358356714e2" />

<img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/2c701bdb-8595-4dfe-ad01-72b7543fd628" />

<img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/7beec011-26b0-4b72-9961-43e87324c645" />

<img width="1292" height="664" alt="image" src="https://github.com/user-attachments/assets/c9682058-e077-4a40-ba9f-5d567d89170d" />

> Таких эхо-запросов и ответоа будет ещё 3.

> Обратите внимание на ARP таблицу до команды ping и после.

 <img width="639" height="772" alt="image" src="https://github.com/user-attachments/assets/355f1d7e-1e3e-4b4e-98a8-0a92d1cfd679" />

На этом симуляцию можно завершить.
